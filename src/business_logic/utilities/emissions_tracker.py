import multiprocessing
import os
import threading
import time
from typing import Callable

from codecarbon import OfflineEmissionsTracker


def flush_tracker_periodically(
        tracker,
        interval
) -> None:
    """
    This method flushes the emissions data to the output directory at regular intervals.

    :param tracker: The emissions tracker object.
    :param interval: The interval in seconds at which the emissions data will be flushed to the output directory.
    """
    while True:
        tracker.flush()
        time.sleep(interval)


def tracked_function(
        _command: Callable,
        _output_dir,
        _interval,
        _args: tuple | None = None,
) -> None:
    """
    This method runs the given command and tracks the emissions generated by the command.

    :param _command: The command to be run in a separate process through the shell.
    :param _output_dir: The directory where the emissions data will be stored.
    :param _interval: The interval in seconds at which the emissions data will be flushed to the output directory.
    :param _args: The arguments to be passed to the command.
    """
    # Create the output directory, if it does not exist
    if not os.path.exists(_output_dir):
        os.makedirs(_output_dir)

    tracker = OfflineEmissionsTracker(
        country_iso_code="ITA",
        measure_power_secs=_interval,
        project_name="nomenclature_mapping_project",
        output_dir=_output_dir,
    )

    tracker.start()

    # Start a thread for periodic flushing
    flush_thread = threading.Thread(
        target=flush_tracker_periodically,
        args=(tracker, _interval,)
    )
    flush_thread.daemon = True  # Daemonize the thread, so it exits when the main thread exits
    flush_thread.start()

    try:
        process = multiprocessing.Process(
            target=_command,
            args=(_args,) if _args else (),
        )
        process.start()
        process.join()
    finally:
        tracker.stop()
